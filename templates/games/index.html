<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>🐍 Snake — 反應與鍵盤練習</title>
    <style>
      :root {
        --bg: #0b1020; /* 深色背景，護眼 */
        --panel: #111831; /* 面板底色 */
        --edge: #1e2a56; /* 邊框 */
        --text: #e8ecf8; /* 主要文字 */
        --muted: #8ea3c7; /* 次要文字 */
        --accent: #69e1ff; /* 重點色 */
        --accent2: #7cff67; /* 次重點 */
        --warn: #ffd166; /* 特殊點數 */
        --danger: #ff6b6b; /* 撞牆/失敗 */
        --good: #9bff9b; /* 吃到果實 */
        --grid: #0f142b; /* 棋盤線 */
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        background: radial-gradient(
          1200px 800px at 70% -10%,
          #13224a,
          var(--bg)
        );
        color: var(--text);
        font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto,
          "PingFang TC", "Noto Sans TC", "Microsoft JhengHei", Arial,
          "Apple Color Emoji", "Segoe UI Emoji";
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 16px;
      }
      .wrap {
        width: min(1100px, 100%);
        display: grid;
        grid-template-columns: 1fr 340px;
        gap: 16px;
      }
      @media (max-width: 980px) {
        .wrap {
          grid-template-columns: 1fr;
        }
      }

      .card {
        background: linear-gradient(
            180deg,
            rgba(255, 255, 255, 0.03),
            rgba(0, 0, 0, 0.05)
          ),
          var(--panel);
        border: 1px solid var(--edge);
        border-radius: 18px;
        padding: 14px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }
      .title {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 10px;
        border-bottom: 1px dashed #2a386d;
        margin-bottom: 10px;
      }
      .title b {
        font-size: 18px;
        letter-spacing: 0.4px;
      }
      .title .hint {
        margin-left: auto;
        color: var(--muted);
        font-size: 12px;
      }

      canvas {
        display: block;
        width: 100%;
        height: auto;
        background: linear-gradient(
            180deg,
            rgba(255, 255, 255, 0.02),
            rgba(0, 0, 0, 0.12)
          ),
          #0b1433;
        border-radius: 14px;
        border: 1px solid #1d2a55;
      }

      .hud {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
        margin-top: 10px;
      }
      .stat {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid #22346d;
        border-radius: 12px;
        padding: 10px;
      }
      .stat h4 {
        margin: 0 0 6px;
        font-size: 12px;
        color: var(--muted);
        font-weight: 500;
      }
      .stat .val {
        font-size: 22px;
        font-weight: 700;
        letter-spacing: 0.5px;
      }

      .controls {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }
      .row {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .row label {
        width: 120px;
        color: var(--muted);
        font-size: 13px;
      }
      .row input[type="range"] {
        width: 100%;
      }
      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        border: 1px solid #2a3b76;
        border-radius: 12px;
        cursor: pointer;
        user-select: none;
      }
      .toggle input {
        appearance: none;
        width: 38px;
        height: 22px;
        border-radius: 999px;
        background: #20305f;
        position: relative;
        outline: none;
        transition: 0.2s;
        border: 1px solid #2a3b76;
      }
      .toggle input:checked {
        background: #245a2b;
        border-color: #38793f;
      }
      .toggle input::after {
        content: "";
        position: absolute;
        top: 2px;
        left: 2px;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #cfe7ff;
        transition: 0.2s;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      }
      .toggle input:checked::after {
        left: calc(100% - 20px);
        background: #d8ffe0;
      }

      .btnbar {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }
      .btn {
        position: relative;
        appearance: none;
        border: none;
        background: linear-gradient(180deg, #203062, #152147);
        color: var(--text);
        padding: 10px 14px;
        border-radius: 12px;
        cursor: pointer;
        font-weight: 700;
        letter-spacing: 0.3px;
        border: 1px solid #2b3c73;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05),
          0 8px 16px rgba(0, 0, 0, 0.25);
      }
      .btn:active {
        transform: translateY(1px);
      }
      .btn.primary {
        background: linear-gradient(180deg, #2a7ea6, #1c3f6e);
        border-color: #2a77a1;
      }
      .btn.warn {
        background: linear-gradient(180deg, #a6652a, #6e3f1c);
        border-color: #a1732a;
      }

      .kbd {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 22px;
        padding: 2px 6px;
        border-radius: 6px;
        border: 1px solid #2d396b;
        background: #10173a;
        font-size: 12px;
      }
      .legend {
        color: var(--muted);
        font-size: 13px;
        line-height: 1.6;
      }

      .ghost {
        opacity: 0.7;
      }

      .toast {
        position: fixed;
        left: 50%;
        top: 20px;
        transform: translateX(-50%);
        background: #0c1b3e;
        color: #dff5ff;
        padding: 10px 14px;
        border: 1px solid #2a3c78;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        font-weight: 700;
        display: none;
      }

      .mobile-pad {
        display: none;
        gap: 8px;
        justify-content: center;
        margin-top: 8px;
      }
      .pad-btn {
        width: 64px;
        height: 64px;
        border-radius: 14px;
        border: 1px solid #2a3970;
        background: #0e1636;
        color: #cfe2ff;
        font-size: 20px;
        font-weight: 900;
      }
      @media (max-width: 740px) {
        .mobile-pad {
          display: flex;
        }
      }
    </style>
  </head>
  <body>
    <div class="toast" id="toast"></div>
    <div class="wrap">
      <div class="card" id="left">
        <div class="title">
          <b>🐍 Snake — 反應與鍵盤練習</b
          ><span class="hint">箭頭 / WASD｜空白鍵暫停｜R 重開</span>
        </div>
        <canvas
          id="stage"
          width="480"
          height="480"
          aria-label="snake-game-canvas"
        ></canvas>
        <div class="mobile-pad" aria-hidden="true">
          <button class="pad-btn" data-dir="up">▲</button>
        </div>
        <div class="mobile-pad" aria-hidden="true">
          <button class="pad-btn" data-dir="left">◄</button>
          <button class="pad-btn" data-dir="down">▼</button>
          <button class="pad-btn" data-dir="right">►</button>
        </div>
        <div class="hud">
          <div class="stat">
            <h4>分數</h4>
            <div class="val" id="score">0</div>
          </div>
          <div class="stat">
            <h4>最佳紀錄</h4>
            <div class="val" id="best">0</div>
          </div>
          <div class="stat">
            <h4>長度</h4>
            <div class="val" id="length">3</div>
          </div>
          <div class="stat">
            <h4>速度 (格/秒)</h4>
            <div class="val" id="speedVal">7</div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="title">
          <b>控制面板</b><span class="hint">公司同事練習用 💪</span>
        </div>
        <div class="controls">
          <div class="row">
            <label>速度</label>
            <input
              id="speed"
              type="range"
              min="3"
              max="20"
              step="1"
              value="7"
            />
          </div>
          <div class="row">
            <label>棋盤大小</label>
            <input
              id="grid"
              type="range"
              min="12"
              max="34"
              step="2"
              value="22"
            />
          </div>
          <div class="row">
            <label>穿牆/撞牆</label>
            <label class="toggle"
              ><input id="wrap" type="checkbox" checked />
              <span>穿牆（從另一側出來）</span></label
            >
          </div>
          <div class="row">
            <label>障礙物</label>
            <label class="toggle"
              ><input id="obstacle" type="checkbox" />
              <span>加入隨機障礙</span></label
            >
          </div>
          <div class="btnbar">
            <button class="btn primary" id="btnStart">▶ 開始 / 暫停</button>
            <button class="btn" id="btnReset">↻ 重新開始 (R)</button>
            <button class="btn warn" id="btnFocus">⌨️ 鍵盤焦點</button>
          </div>
          <div class="legend">
            <p>
              操作：<span class="kbd">↑</span><span class="kbd">↓</span
              ><span class="kbd">←</span><span class="kbd">→</span> 或
              <span class="kbd">W</span><span class="kbd">A</span
              ><span class="kbd">S</span><span class="kbd">D</span>，<span
                class="kbd"
                >Space</span
              >
              暫停、<span class="kbd">R</span> 重開。
            </p>
            <p>
              目標：吃到 <span class="kbd">●</span>（5 分）讓蛇變長。偶爾出現的
              <span class="kbd">★</span>（10 分）會限時消失！
            </p>
          </div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        // 基本狀態
        const canvas = document.getElementById("stage");
        const ctx = canvas.getContext("2d");
        const scoreEl = document.getElementById("score");
        const bestEl = document.getElementById("best");
        const lenEl = document.getElementById("length");
        const speedInput = document.getElementById("speed");
        const speedValEl = document.getElementById("speedVal");
        const gridInput = document.getElementById("grid");
        const wrapInput = document.getElementById("wrap");
        const obsInput = document.getElementById("obstacle");
        const toast = document.getElementById("toast");

        const btnStart = document.getElementById("btnStart");
        const btnReset = document.getElementById("btnReset");
        const btnFocus = document.getElementById("btnFocus");

        const padBtns = document.querySelectorAll(".pad-btn");

        let GRID = parseInt(gridInput.value, 10); // N x N
        let SPEED = parseInt(speedInput.value, 10); // cells per second
        const BASE_CELL = 22; // base pixel size at 22 grid for 480 canvas

        // 持久化最佳紀錄
        const BEST_KEY = "snake_best_v1";
        let best = parseInt(localStorage.getItem(BEST_KEY) || "0", 10);
        bestEl.textContent = best;

        // 遊戲狀態
        let snake,
          dir,
          nextDir,
          food,
          bonus,
          bonusTTL,
          obstacles,
          running,
          acc,
          tickElapsed;

        function cellSize() {
          // 依 GRID 動態計算像素尺寸（確保等比）
          return Math.floor(Math.min(canvas.width, canvas.height) / GRID);
        }

        function resizeCanvas() {
          const left = document.getElementById("left");
          const w = left.clientWidth - 2; // padding/border 誤差
          const target = Math.min(w, 640);
          const snap = Math.round(target / 10) * 10; // 取整數
          canvas.width = snap;
          canvas.height = snap;
        }

        window.addEventListener("resize", () => {
          resizeCanvas();
          draw();
        });
        resizeCanvas();

        function resetGame() {
          GRID = parseInt(gridInput.value, 10);
          SPEED = parseInt(speedInput.value, 10);
          speedValEl.textContent = SPEED;

          const mid = Math.floor(GRID / 2);
          snake = [
            { x: mid, y: mid },
            { x: mid - 1, y: mid },
            { x: mid - 2, y: mid },
          ];
          dir = { x: 1, y: 0 };
          nextDir = { ...dir };
          obstacles = obsInput.checked
            ? genObstacles(Math.floor(GRID * 0.7))
            : [];
          food = spawnFreeCell();
          bonus = null;
          bonusTTL = 0;
          running = false;
          acc = 0;
          tickElapsed = 0;

          updateHUD(0);
          draw();
        }

        function updateHUD(score) {
          scoreEl.textContent = score;
          lenEl.textContent = snake.length;
          speedValEl.textContent = SPEED;
        }

        function randomInt(n) {
          return Math.floor(Math.random() * n);
        }

        function isOccCell(x, y) {
          return (
            snake.some((p) => p.x === x && p.y === y) ||
            obstacles.some((o) => o.x === x && o.y === y)
          );
        }

        function spawnFreeCell() {
          let x,
            y,
            guard = 0;
          do {
            x = randomInt(GRID);
            y = randomInt(GRID);
            guard++;
            if (guard > 5000) break;
          } while (isOccCell(x, y));
          return { x, y };
        }

        function genObstacles(count) {
          const list = [];
          let tries = 0;
          while (list.length < count && tries < GRID * GRID) {
            tries++;
            const c = { x: randomInt(GRID), y: randomInt(GRID) };
            // 避開中央起始區域
            const mid = Math.floor(GRID / 2);
            const safe = Math.abs(c.x - mid) > 3 || Math.abs(c.y - mid) > 3;
            if (safe && !list.some((o) => o.x === c.x && o.y === c.y))
              list.push(c);
          }
          return list;
        }

        function showToast(msg) {
          toast.textContent = msg;
          toast.style.display = "block";
          clearTimeout(showToast.tid);
          showToast.tid = setTimeout(() => {
            toast.style.display = "none";
          }, 1100);
        }

        // 繪圖
        function draw() {
          const cs = cellSize();
          const size = cs * GRID;
          // 背景與棋盤
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#0b1433";
          ctx.fillRect(0, 0, size, size);

          // 棋盤格線（細）
          ctx.strokeStyle = "rgba(255,255,255,0.04)";
          ctx.lineWidth = 1;
          for (let i = 1; i < GRID; i++) {
            ctx.beginPath();
            ctx.moveTo(i * cs + 0.5, 0);
            ctx.lineTo(i * cs + 0.5, size);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, i * cs + 0.5);
            ctx.lineTo(size, i * cs + 0.5);
            ctx.stroke();
          }

          // 障礙
          if (obstacles.length) {
            ctx.fillStyle = "#1f295a";
            obstacles.forEach((o) => {
              roundRect(ctx, o.x * cs, o.y * cs, cs, cs, 6, true, false);
            });
          }

          // 食物
          if (food) {
            ctx.fillStyle = "#6fffa2";
            drawDot(
              ctx,
              food.x * cs + cs / 2,
              food.y * cs + cs / 2,
              Math.max(4, cs * 0.18)
            );
          }

          // Bonus
          if (bonus) {
            ctx.fillStyle = "#ffd166";
            star(
              ctx,
              bonus.x * cs + cs / 2,
              bonus.y * cs + cs / 2,
              Math.max(5, cs * 0.22)
            );
          }

          // 蛇
          for (let i = 0; i < snake.length; i++) {
            const p = snake[i];
            const t = i / (snake.length - 1 || 1);
            const grad = lerpColor([105, 225, 255], [124, 255, 103], t);
            ctx.fillStyle = `rgb(${grad[0]},${grad[1]},${grad[2]})`;
            roundRect(
              ctx,
              p.x * cs + 1,
              p.y * cs + 1,
              cs - 2,
              cs - 2,
              6,
              true,
              false
            );
          }

          // 暫停遮罩
          if (!running) {
            ctx.fillStyle = "rgba(0,0,0,0.25)";
            ctx.fillRect(0, 0, size, size);
            ctx.fillStyle = "rgba(255,255,255,0.85)";
            ctx.font = `${Math.floor(cs * 0.9)}px system-ui, sans-serif`;
            ctx.textAlign = "center";
            ctx.fillText("按 ▶ 或空白鍵開始", size / 2, size / 2 + cs * 0.1);
          }
        }

        function star(ctx, x, y, r) {
          const spikes = 5;
          let rot = (Math.PI / 2) * 3;
          let step = Math.PI / spikes;
          let R = r,
            r2 = r * 0.5;
          ctx.beginPath();
          ctx.moveTo(x, y - R);
          for (let i = 0; i < spikes; i++) {
            ctx.lineTo(x + Math.cos(rot) * R, y + Math.sin(rot) * R);
            rot += step;
            ctx.lineTo(x + Math.cos(rot) * r2, y + Math.sin(rot) * r2);
            rot += step;
          }
          ctx.lineTo(x, y - R);
          ctx.closePath();
          ctx.fill();
        }

        function drawDot(ctx, x, y, r) {
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
        }
        function roundRect(ctx, x, y, w, h, r, fill, stroke) {
          if (w < 2 * r) r = w / 2;
          if (h < 2 * r) r = h / 2;
          ctx.beginPath();
          ctx.moveTo(x + r, y);
          ctx.arcTo(x + w, y, x + w, y + h, r);
          ctx.arcTo(x + w, y + h, x, y + h, r);
          ctx.arcTo(x, y + h, x, y, r);
          ctx.arcTo(x, y, x + w, y, r);
          ctx.closePath();
          if (fill) ctx.fill();
          if (stroke) ctx.stroke();
        }
        function lerpColor(a, b, t) {
          return [
            Math.round(a[0] + (b[0] - a[0]) * t),
            Math.round(a[1] + (b[1] - a[1]) * t),
            Math.round(a[2] + (b[2] - a[2]) * t),
          ];
        }

        // 方向控制
        function setDirection(nx, ny) {
          // 禁止直接反向
          if (nx === -dir.x && ny === -dir.y) return;
          nextDir = { x: nx, y: ny };
        }

        document.addEventListener("keydown", (e) => {
          const k = e.key.toLowerCase();
          if (["arrowup", "w"].includes(k)) {
            e.preventDefault();
            setDirection(0, -1);
          } else if (["arrowdown", "s"].includes(k)) {
            e.preventDefault();
            setDirection(0, 1);
          } else if (["arrowleft", "a"].includes(k)) {
            e.preventDefault();
            setDirection(-1, 0);
          } else if (["arrowright", "d"].includes(k)) {
            e.preventDefault();
            setDirection(1, 0);
          } else if (k === " ") {
            e.preventDefault();
            toggleRun();
          } else if (k === "r") {
            e.preventDefault();
            resetGame();
            running = true;
            showToast("重新開始");
          }
        });

        padBtns.forEach((b) =>
          b.addEventListener("click", () => {
            const d = b.dataset.dir;
            if (d === "up") setDirection(0, -1);
            if (d === "down") setDirection(0, 1);
            if (d === "left") setDirection(-1, 0);
            if (d === "right") setDirection(1, 0);
          })
        );

        // 面板事件
        speedInput.addEventListener("input", () => {
          SPEED = parseInt(speedInput.value, 10);
          speedValEl.textContent = SPEED;
        });
        gridInput.addEventListener("change", () => {
          resetGame();
        });
        wrapInput.addEventListener("change", () => {
          /* 即時生效 */
        });
        obsInput.addEventListener("change", () => {
          resetGame();
        });

        btnStart.addEventListener("click", toggleRun);
        btnReset.addEventListener("click", () => {
          resetGame();
          running = true;
          showToast("重新開始");
        });
        btnFocus.addEventListener("click", () => {
          canvas.focus();
          showToast("已將鍵盤焦點設為畫面");
        });

        function toggleRun() {
          running = !running;
          if (running) {
            showToast("開始");
          }
          draw();
        }

        // 主要更新（離散格子時間）
        let lastTime = performance.now();
        function loop(now) {
          const dt = (now - lastTime) / 1000;
          lastTime = now;

          if (running) {
            acc += dt;
            const step = 1 / Math.max(1, SPEED);
            while (acc >= step) {
              acc -= step;
              stepOnce();
            }
          }

          draw();
          requestAnimationFrame(loop);
        }

        function stepOnce() {
          dir = nextDir; // 將排程方向套用
          const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

          // 邊界處理：穿牆或撞牆
          if (wrapInput.checked) {
            // wrap
            head.x = (head.x + GRID) % GRID;
            head.y = (head.y + GRID) % GRID;
          } else {
            if (head.x < 0 || head.y < 0 || head.x >= GRID || head.y >= GRID) {
              return gameOver("撞牆啦！");
            }
          }

          // 自撞 / 障礙
          if (snake.some((p) => p.x === head.x && p.y === head.y))
            return gameOver("咬到自己！");
          if (obstacles.some((o) => o.x === head.x && o.y === head.y))
            return gameOver("撞到障礙！");

          snake.unshift(head); // 前進

          let gained = 0;
          if (food && head.x === food.x && head.y === food.y) {
            gained += 5;
            food = spawnFreeCell();
            // 小機率出現 Bonus
            if (Math.random() < 0.35 && !bonus) {
              bonus = spawnFreeCell();
              bonusTTL = Math.max(6, Math.round(GRID * 0.35));
            }
          } else {
            snake.pop(); // 沒吃到就移除尾端
          }

          if (bonus) {
            bonusTTL--;
            if (head.x === bonus.x && head.y === bonus.y) {
              gained += 10;
              bonus = null;
              bonusTTL = 0;
              showToast("+10 ★");
            } else if (bonusTTL <= 0) {
              bonus = null;
            }
          }

          const score = parseInt(scoreEl.textContent, 10) + gained;
          if (score > best) {
            best = score;
            localStorage.setItem(BEST_KEY, String(best));
            bestEl.textContent = best;
          }
          updateHUD(score);
        }

        function gameOver(msg) {
          running = false;
          showToast("GAME OVER｜" + msg);
          // 閃紅效果
          canvas.animate(
            [
              { filter: "none" },
              { filter: "contrast(140%) saturate(130%) hue-rotate(-25deg)" },
              { filter: "none" },
            ],
            { duration: 600, iterations: 1 }
          );
        }

        // 啟動
        resetGame();
        requestAnimationFrame(loop);
      })();
    </script>
  </body>
</html>
